
#include"EraserLayer.h"
#include "../utils/Utility.h"
//主要用来测试利用RenderTexture, visit 一张底图和 一个移动的笔刷图片不断混合的结果，
//RenderTexture 背后还有背景图片等等
EraserLayer::~EraserLayer()
{
	eraserPencil->release();
	spriteBG->release();
}

bool EraserLayer::init()
{
	CCLayer::init();
	auto visibleSize = Director::getInstance()->getWinSize();
	//bg
	
	auto bgSP = Sprite::create("Images/landscape-1024x1024.png");
	this->addChild(bgSP);

	//创建一个橡皮擦  
	eraserPencil = Sprite::create("hole_effect.png"); //hole_effect eraser
	eraserPencil->retain();

	//创建画布，并显示  
	rTex = RenderTexture::create(visibleSize.width, visibleSize.height);
	rTex->setPosition(visibleSize.width / 2, visibleSize.height / 2);
	this->addChild(rTex);

	//创建需要被擦除的内容  
	spriteBG = Sprite::create("assetMgrBackground2.png");  //assetMgrBackground2 HelloWorld
	spriteBG->setPosition(visibleSize.width / 2, visibleSize.height / 2);
	spriteBG->retain();
	//将内容渲染到画布上  
	/*rTex->begin();
	spriteBG->visit();
	rTex->end();*/

	//检测触摸
	auto el = EventListenerTouchOneByOne::create();
	el->setSwallowTouches(true);

	el->onTouchBegan = [=](Touch* touch, Event* event)
	{
		auto pos1 = touch->getLocation();
		log("onTouchBegan:%f,%f", pos1.x, pos1.y);


		return true;
	};

	el->onTouchEnded = [=](Touch* touch, Event* event)
	{
		auto pos1 = touch->getLocation();
		
	};

	el->onTouchMoved = [=](Touch* touch, Event* event)
	{

		auto pos1 = touch->getLocation();
		log("moved1:%f,%f", pos1.x, pos1.y);

		//将橡皮设置到点击的位置  
		Vec2 touchPoint = touch->getLocation();
		eraserPencil->setPosition(touchPoint);

		//设置混合方式  
		//BlendFunc blendFunc = { GL_ONE_MINUS_SRC_ALPHA, GL_ZERO }; //GL_ONE, GL_ZERO  | GL_ZERO, GL_SRC_ALPHA |GL_ONE_MINUS_SRC_ALPHA,GL_ZERO
		//eraserPencil->setBlendFunc(blendFunc);

		//GL_DST_ALPHA, GL_ZERO ：GL_DST_ALPHA*self.color  +  GL_ZERO*pencil.color
		BlendFunc blendFunc1 = { GL_DST_ALPHA, GL_ZERO }; //GL_ONE, GL_ZERO  | GL_ZERO, GL_SRC_ALPHA |GL_ONE_MINUS_SRC_ALPHA,GL_ZERO
		spriteBG->setBlendFunc(blendFunc1);

		//开擦！  
		rTex->begin();
		eraserPencil->visit(); //target
		spriteBG->visit(); //src
		rTex->end();
	};

	auto dispatcher = Director::getInstance()->getEventDispatcher();
	dispatcher->addEventListenerWithSceneGraphPriority(el, this);
	return true;
}